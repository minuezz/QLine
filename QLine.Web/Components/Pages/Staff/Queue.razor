@page "/staff/queue"
@attribute [Authorize(Policy = "StaffOnly")]
@implements IAsyncDisposable
@using System.Timers
@using Microsoft.AspNetCore.Authorization
@using Microsoft.JSInterop
@using MediatR
@using QLine.Application.DTO
@using QLine.Application.Features.Queue.Queries
@using QLine.Application.Features.Queue.Commands
@inject IMediator Mediator
@inject IJSRuntime JS

<MudStack Spacing="3">
    <MudText Typo="Typo.h4" Class="font-weight-bold">Staff Queue</MudText>

    @if (!string.IsNullOrWhiteSpace(_accessMessage))
    {
        <MudAlert Severity="Severity.Error" Variant="Variant.Filled">@_accessMessage</MudAlert>
    }
    else
    {
        @if (_points.Count > 1 && !HasSelectedServicePoint)
        {
            <MudCard Elevation="1">
                <MudCardHeader Title="Where are you working today?" />
                <MudCardContent>
                    <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                        <MudSelect @bind-Value="_selectionCandidateId" FullWidth="true" Label="Service Point">
                            @foreach (var sp in _points)
                            {
                                <MudSelectItem Value="@sp.Id.ToString()">@sp.Name</MudSelectItem>
                            }
                        </MudSelect>
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ConfirmServicePointAsync">Load Queue</MudButton>
                    </MudStack>
                    @if (!string.IsNullOrWhiteSpace(_selectionError))
                    {
                        <MudText Color="Color.Error" Typo="Typo.caption">@_selectionError</MudText>
                    }
                </MudCardContent>
            </MudCard>
        }

        @if (HasSelectedServicePoint)
        {
            <MudPaper Class="pa-3" Elevation="1">
                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.subtitle1">Service Point:</MudText>
                    <MudSelect @bind-Value="SelectedServicePointIdString" @bind-Value:after="OnServicePointChanged" Label="Select" Immediate="true" Dense="true">
                        @foreach (var sp in _points)
                        {
                            <MudSelectItem Value="@sp.Id.ToString()">@sp.Name</MudSelectItem>
                        }
                    </MudSelect>
                    <MudSpacer />
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="CallNextAsync" Disabled="_isProcessing">
                        <MudIcon Icon="@Icons.Material.Filled.NextPlan" Class="mr-1" />
                        Call Next
                    </MudButton>
                </MudStack>
            </MudPaper>

            <MudGrid Class="mt-2" Spacing="3">
                <MudItem xs="12" md="8">
                    <MudCard Elevation="3" Class="high-emphasis-card">
                        <MudCardHeader Title="Current Ticket" />
                        <MudCardContent>
                            @if (_snapshot is null)
                            {
                                <MudProgressCircular Color="Color.Primary" Size="Size.Large" Class="my-4" />
                            }
                            else if (_snapshot.Current is null)
                            {
                                <MudText Typo="Typo.subtitle1" Color="Color.Secondary">No ticket in service.</MudText>
                            }
                            else
                            {
                                <MudStack Spacing="2">
                                    <MudPaper Elevation="0" Class="pa-3 high-emphasis-card">
                                        <MudText Typo="Typo.subtitle2" Color="Color.Primary">Now Serving</MudText>
                                        <MudText Typo="Typo.h1" Class="font-weight-bold">@_snapshot.Current.TicketNo</MudText>
                                        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                                            <MudChip T="string" Color="Color.Primary" Variant="Variant.Filled">@_snapshot.Current.Status</MudChip>
                                            <MudChip T="string" Color="Color.Info" Variant="Variant.Outlined">Priority @_snapshot.Current.Priority</MudChip>

                                            <MudText Color="@GetDurationColor(_snapshot.Current.CreatedAt)" Typo="Typo.subtitle1" Class="font-weight-bold">
                                                @FormatDuration(_snapshot.Current.CreatedAt)
                                            </MudText>
                                        </MudStack>
                                    </MudPaper>

                                    <MudStack Row="true" Spacing="2">
                                        <MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Large" OnClick="CallNextAsync" Disabled="_isProcessing">
                                            <MudIcon Icon="@Icons.Material.Filled.NextPlan" Class="mr-1" />
                                            Call Next
                                        </MudButton>
                                        <MudButton Variant="Variant.Filled" Color="Color.Success" Size="Size.Large" Disabled="_snapshot.Current is null || _isProcessing" OnClick="() => MarkDoneAsync(_snapshot.Current!.Id)">
                                            <MudIcon Icon="@Icons.Material.Filled.Check" Class="mr-1" />
                                            Done
                                        </MudButton>
                                        <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Large" Disabled="_snapshot.Current is null || _isProcessing" OnClick="() => MarkNoShowAsync(_snapshot.Current!.Id)">
                                            <MudIcon Icon="@Icons.Material.Filled.PersonOff" Class="mr-1" />
                                            No Show
                                        </MudButton>
                                    </MudStack>
                                </MudStack>
                            }
                        </MudCardContent>
                    </MudCard>
                </MudItem>
                <MudItem xs="12" md="4">
                    <MudCard Elevation="2" Class="fade-in">
                        <MudCardHeader>
                            <CardHeaderContent>
                                <MudText Typo="Typo.h6">Waiting Queue</MudText>
                            </CardHeaderContent>
                            <CardHeaderActions>
                                <MudBadge Color="Color.Primary" Content="@(_snapshot?.Waiting.Count ?? 0)" Overlap="true" />
                            </CardHeaderActions>
                        </MudCardHeader>
                        <MudCardContent>
                            @if (_snapshot is null)
                            {
                                <MudSkeleton Height="40px" />
                            }
                            else if (_snapshot.Waiting.Count == 0)
                            {
                                <MudText Typo="Typo.subtitle2" Color="Color.Secondary">No one waiting.</MudText>
                            }
                            else
                            {
                                <MudList T="string" Class="fade-in">
                                    @foreach (var w in _snapshot.Waiting)
                                    {
                                        <MudListItem T="string" Class="fade-in">
                                            <div class="d-flex align-center justify-space-between">

                                                <div class="d-flex align-center">
                                                    <MudIcon Icon="@Icons.Material.Filled.Schedule" Color="Color.Secondary" Class="mr-3" />
                                                    <div>
                                                        <MudText Typo="Typo.subtitle1" Class="font-weight-bold">@w.TicketNo</MudText>
                                                        <MudText Typo="Typo.caption" Color="Color.Secondary">Waiting @FormatDuration(w.CreatedAt)</MudText>
                                                    </div>
                                                </div>

                                                <MudTooltip Text="Skip this customer">
                                                    <MudIconButton Icon="@Icons.Material.Filled.SkipNext"
                                                                   Color="Color.Secondary"
                                                                   Disabled="_isProcessing"
                                                                   OnClick="() => SkipAsync(w.Id)" />
                                                </MudTooltip>
                                            </div>
                                        </MudListItem>
                                    }
                                </MudList>
                            }
                        </MudCardContent>
                    </MudCard>
                </MudItem>
            </MudGrid>
        }
    }
</MudStack>

@code {
    private List<ServicePointDto> _points = new();

    private string? SelectedServicePointIdString;
    private string? _selectionCandidateId;
    private string? _selectionError;
    private string? _accessMessage;

    private IJSObjectReference? _realtimeHandle;
    private Guid? _connectedSpId;
    private bool _realtimeReady;

    private QueueSnapshotDto? _snapshot;

    private readonly SemaphoreSlim _refreshGate = new(1, 1);

    private bool _isProcessing;
    private Timer? _timer;
    private DateTimeOffset _now = DateTimeOffset.UtcNow;

    private bool HasSelectedServicePoint =>
        Guid.TryParse(SelectedServicePointIdString, out var sp) && _points.Any(p => p.Id == sp);

    protected override async Task OnInitializedAsync()
    {
        _points = (await Mediator.Send(new GetMyServicePointsQuery())).ToList();

        if (_points.Count == 0)
        {
            _accessMessage = "You are not assigned to any service point. Please contact an administrator.";
            return;
        }

        if (_points.Count == 1)
        {
            SelectedServicePointIdString = _points[0].Id.ToString();
            await RefreshAsync();
        }
        else
        {
            _selectionCandidateId = _points[0].Id.ToString();
        }

        _timer = new Timer(1000) { AutoReset = true, Enabled = true };
        _timer.Elapsed += (_, _) =>
        {
            _now = DateTimeOffset.UtcNow;
            InvokeAsync(StateHasChanged);
        };
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _realtimeReady = true;
            if (HasSelectedServicePoint)
                await ConnectToRealtimeAsync();
        }
    }

    private async Task OnServicePointChanged()
    {
        if (!HasSelectedServicePoint)
        {
            _selectionError = "Invalid service point selection.";
            StateHasChanged();
            return;
        }

        await ConnectToRealtimeAsync();
        await RefreshAsync();
    }

    private async Task ConfirmServicePointAsync()
    {
        if (string.IsNullOrWhiteSpace(_selectionCandidateId) || !Guid.TryParse(_selectionCandidateId, out var candidate))
        {
            _selectionError = "Select a service point.";
            return;
        }

        if (!_points.Any(p => p.Id == candidate))
        {
            _selectionError = "You cannot select this service point.";
            return;
        }

        SelectedServicePointIdString = candidate.ToString();
        _selectionError = null;

        await OnServicePointChanged();
    }

    private async Task ConnectToRealtimeAsync()
    {
        if (!_realtimeReady) return;
        if (string.IsNullOrWhiteSpace(SelectedServicePointIdString)) return;
        if (!Guid.TryParse(SelectedServicePointIdString, out var sp)) return;
        if (!_points.Any(p => p.Id == sp)) return;

        if (_connectedSpId == sp) return;

        if (_realtimeHandle is not null)
        {
            try
            {
                await _realtimeHandle.InvokeVoidAsync("dispose");
            }
            catch
            {

            }
            _realtimeHandle = null;
            _connectedSpId = null;
        }

        _realtimeHandle = await JS.InvokeAsync<IJSObjectReference>(
                        "qlineRealtime.connect", sp, DotNetObjectReference.Create(this));
        _connectedSpId = sp;
    }

    private async Task RefreshAsync()
    {
        if (string.IsNullOrWhiteSpace(SelectedServicePointIdString)) return;
        if (!Guid.TryParse(SelectedServicePointIdString, out var sp)) return;
        if (!_points.Any(p => p.Id == sp)) return;

        await _refreshGate.WaitAsync();
        try
        {
            _snapshot = await Mediator.Send(new GetQueueQuery(sp));
            StateHasChanged();
        }
        finally
        {
            _refreshGate.Release();
        }
    }

    [JSInvokable]
    public Task OnQueueUpdated() => RefreshAsync();

    public async ValueTask DisposeAsync()
    {
        _timer?.Stop();
        _timer?.Dispose();

        if (_realtimeHandle is not null)
            await _realtimeHandle.InvokeVoidAsync("dispose");
    }

    private async Task CallNextAsync()
    {
        if (_isProcessing) return;
        _isProcessing = true;

        try
        {
            if (!Guid.TryParse(SelectedServicePointIdString, out var sp)) return;
            if (!_points.Any(p => p.Id == sp)) return;

            await _refreshGate.WaitAsync();
            try
            {
                await Mediator.Send(new CallNextCommand(sp));
            }
            finally
            {
                _refreshGate.Release();
            }
        }
        finally
        {
            _isProcessing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task MarkNoShowAsync(Guid id)
    {
        if (_isProcessing) return;
        _isProcessing = true;

        try
        {
            await _refreshGate.WaitAsync();
            try
            {
                await Mediator.Send(new MarkNoShowCommand(id));
            }
            finally
            {
                _refreshGate.Release();
            }
        }
        finally
        {
            _isProcessing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task MarkDoneAsync(Guid id)
    {
        if (_isProcessing) return;
        _isProcessing = true;

        try
        {
            await _refreshGate.WaitAsync();
            try
            {
                await Mediator.Send(new MarkDoneCommand(id));
            }
            finally
            {
                _refreshGate.Release();
            }
        }
        finally
        {
            _isProcessing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SkipAsync(Guid id)
    {
        if (_isProcessing) return;
        _isProcessing = true;

        try
        {
            await _refreshGate.WaitAsync();
            try
            {
                await Mediator.Send(new SkipQueueEntryCommand(id));
            }
            finally
            {
                _refreshGate.Release();
            }
        }
        finally
        {
            _isProcessing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private string FormatDuration(DateTimeOffset start)
    {
        var duration = _now - start;
        if (duration < TimeSpan.Zero)
            duration = TimeSpan.Zero;

        return $"{(int)duration.TotalMinutes:00}:{duration.Seconds:00}";
    }

    private Color GetDurationColor(DateTimeOffset start)
    {
        var duration = _now - start;
        if (duration.TotalMinutes < 5)
            return Color.Success;
        if (duration.TotalMinutes < 10)
            return Color.Warning;
        return Color.Error;
    }
}
